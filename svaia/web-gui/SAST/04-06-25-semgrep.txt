                    
                    
┌──────────────────┐
│ 11 Code Findings │
└──────────────────┘
                         
  [36m[22m[24m  app.py[0m
     ❱ [1mpython.flask.web.flask-cookie-secure-false.flask-cookie-secure-false[0m
          Detected a cookie where the `Secure` flag is either missing or disabled. The `Secure` cookie flag 
          instructs the browser to forbid sending the cookie over an insecure HTTP request. Set the `Secure`
          flag to `true` so the cookie will only be sent over HTTPS. If this wasn't intentional, it's       
          recommended to set the Secure flag to true so the cookie will always be sent over HTTPS. A secure 
          default approach would consist of creating a custom response class, overriding the `set_cookie`   
          method to set this flag to `True` by default, setting the `response_class` attribute of your Flask
          app to use the custom response class, setting the flag to False on a case-by-case basis only when 
          necessary.                                                                                        
          Details: https://sg.run/v8reW                                                                     
                                                                                                            
           [32m▶▶┆ Autofix ▶ [0mTrue
           38┆ secure=False,
            ⋮┆----------------------------------------
           [32m▶▶┆ Autofix ▶ [0mTrue
           52┆ flask_response.set_cookie('access_token', '', expires=0, httponly=True, secure=False,
               samesite='Strict', path='/')                                                         
            ⋮┆----------------------------------------
           [32m▶▶┆ Autofix ▶ [0mTrue
           53┆ flask_response.set_cookie('remember_token', '', expires=0, httponly=True, secure=False,
               samesite='Strict', path='/')                                                           
   
   ❯❯❱ [1mpython.flask.security.injection.ssrf-requests.ssrf-requests[0m
          Data from request object is passed to a new server-side request. This could lead to a server-side  
          request forgery (SSRF). To mitigate, ensure that schemes and hosts are validated against an        
          allowlist, do not forward the response to the user, and ensure proper authentication and transport-
          layer security in the proxied request.                                                             
          Details: https://sg.run/J9LW                                                                       
                                                                                                             
          101┆ resp = requests.get(f"{API}/usuario/{nombre_usuario.strip()}")
   
   ❯❯❱ [1mpython.flask.security.open-redirect.open-redirect[0m
          Data from request is passed to redirect(). This is an open redirect and could be exploited. Consider
          using 'url_for()' to generate links to known locations. If you must use a URL to unknown pages,     
          consider using 'urlparse()' or similar and checking if the 'netloc' property is the same as your    
          site's host name. See the references for more information.                                          
          Details: https://sg.run/kXe2                                                                        
                                                                                                              
          136┆ next = request.form.get("next", url_for("proyectos"))
          137┆ return redirect(next, url_for("proyectos"))
   
   ❯❯❱ [1mpython.flask.security.injection.ssrf-requests.ssrf-requests[0m
          Data from request object is passed to a new server-side request. This could lead to a server-side  
          request forgery (SSRF). To mitigate, ensure that schemes and hosts are validated against an        
          allowlist, do not forward the response to the user, and ensure proper authentication and transport-
          layer security in the proxied request.                                                             
          Details: https://sg.run/J9LW                                                                       
                                                                                                             
          142┆ proyecto = requests.get(f"{API}/proyecto/{nombre_proyecto}").json()
            ⋮┆----------------------------------------
          175┆ response = requests.get(f"{API}/proyecto/{nombre_proyecto}",cookies=request.cookies)
                                                
  [36m[22m[24m  templates/crear_proyecto.html[0m
    ❯❱ [1mpython.django.security.django-no-csrf-token.django-no-csrf-token[0m
          Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.
          Details: https://sg.run/N0Bp                                                                   
                                                                                                         
            8┆ <form id="formCrearProyecto" onsubmit="crearProyecto(event)">
            9┆     <div class="mb-3">
           10┆         <label for="nombre" class="form-label">Nombre</label>
           11┆         <input type="text" name="nombre" class="form-control" required>
           12┆     </div>
           13┆      <div class="mb-3">
           14┆         <label for="descripcion" class="form-label">Descripción</label>
           15┆         <textarea id="descripcion" name="descripcion"class="form-control" rows="4"
               placeholder="Opcional..."></textarea>                                             
           16┆      </div>
           17┆     <div class="d-flex gap-2">
             [hid 4 additional lines, adjust with --max-lines-per-finding] 
                                        
  [36m[22m[24m  templates/layout.html[0m
    ❯❱ [1mhtml.security.audit.missing-integrity.missing-integrity[0m
          This tag is missing an 'integrity' subresource integrity attribute. The 'integrity' attribute allows
          for the browser to verify that externally hosted files (for example from a CDN) are delivered       
          without unexpected manipulation. Without this attribute, if an attacker can modify the externally   
          hosted resource, this could lead to XSS and other types of attacks. To prevent this, include the    
          base64-encoded cryptographic hash of the resource (file) you’re telling the browser to fetch in the 
          'integrity' attribute for all externally hosted files.                                              
          Details: https://sg.run/krXA                                                                        
                                                                                                              
           81┆ <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-
               icons@1.11.3/font/bootstrap-icons.min.css">                         
                                       
  [36m[22m[24m  templates/login.html[0m
    ❯❱ [1mpython.django.security.django-no-csrf-token.django-no-csrf-token[0m
          Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.
          Details: https://sg.run/N0Bp                                                                   
                                                                                                         
           87┆ <form method="POST" action="{{ url_for('login') }}">
           88┆   <label for="username">Nombre de usuario:</label>
           89┆   <input type="text" id="username" name="username" required>
           90┆
           91┆   <label for="password">Contraseña:</label>
           92┆   <input type="password" id="password" name="password" required>
           93┆
           94┆   {% if request.args.get('next') %}
           95┆     <input type="hidden" name="next" value="{{ request.args.get('next') }}">
           96┆   {% endif %}
             [hid 3 additional lines, adjust with --max-lines-per-finding] 
                                                   
  [36m[22m[24m  templates/metricas_proyecto.html[0m
    ❯❱ [1mhtml.security.audit.missing-integrity.missing-integrity[0m
          This tag is missing an 'integrity' subresource integrity attribute. The 'integrity' attribute allows
          for the browser to verify that externally hosted files (for example from a CDN) are delivered       
          without unexpected manipulation. Without this attribute, if an attacker can modify the externally   
          hosted resource, this could lead to XSS and other types of attacks. To prevent this, include the    
          base64-encoded cryptographic hash of the resource (file) you’re telling the browser to fetch in the 
          'integrity' attribute for all externally hosted files.                                              
          Details: https://sg.run/krXA                                                                        
                                                                                                              
            4┆ <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
